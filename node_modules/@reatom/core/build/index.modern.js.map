{"version":3,"file":"index.modern.js","sources":["../src/kernel.ts","../src/shared.ts","../src/declareAction.ts","../src/declareAtom.ts","../src/createStore.ts"],"sourcesContent":["export type Leaf = string // unique\nexport type TreeId = string | symbol // unique\nexport type State = Record<TreeId, unknown>\n// reatom specific\nexport type Fn = {\n  (ctx: Ctx): any\n  _ownerAtomId: TreeId\n}\nexport type Ctx = ReturnType<typeof createCtx>\nexport type BaseAction<T = any> = { type: Leaf; payload: T }\nexport function createCtx(state: State, { type, payload }: BaseAction) {\n  return {\n    state,\n    stateNew: {} as State,\n    type,\n    payload,\n    changedIds: [] as TreeId[],\n  }\n}\n\nclass SetCounted {\n  _counter = new Map<Fn, number>()\n\n  add(el: Fn) {\n    this._counter.set(el, (this._counter.get(el) || 0) + 1)\n  }\n\n  delete(el: Fn) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const count = this._counter.get(el)!\n    if (count === 1) {\n      return this._counter.delete(el)\n    }\n    if (count > 1) {\n      this._counter.set(el, count - 1)\n    }\n    return false\n  }\n\n  forEach(cb: (fn: Fn) => any) {\n    this._counter.forEach((_, fn) => cb(fn))\n  }\n}\n\nexport class Tree {\n  id: TreeId\n\n  isLeaf: boolean\n\n  fnsMap: Map<Leaf, SetCounted>\n\n  constructor(id: TreeId, isLeaf = false) {\n    this.id = id\n    this.isLeaf = isLeaf\n    this.fnsMap = new Map()\n  }\n\n  _getFns(key: Leaf) {\n    return (\n      this.fnsMap.get(key) ||\n      (this.fnsMap.set(key, new SetCounted()).get(key) as SetCounted)\n    )\n  }\n\n  addFn(fn: Fn, key: Leaf) {\n    this._getFns(key).add(fn)\n  }\n\n  union(tree: Tree) {\n    tree.fnsMap.forEach((set, key) => {\n      const fns = this._getFns(key)\n      set.forEach(fn => fns.add(fn))\n    })\n  }\n\n  disunion(tree: Tree, cb: (key: TreeId) => any) {\n    tree.fnsMap.forEach((set, key) => {\n      const fns = this._getFns(key)\n      set.forEach(fn => fns.delete(fn) && cb(fn._ownerAtomId))\n    })\n  }\n\n  forEach(key: Leaf, ctx: Ctx) {\n    const setCounted = this.fnsMap.get(key)\n    if (setCounted) setCounted.forEach(fn => fn(ctx))\n  }\n}\n","import { Tree, TreeId } from './kernel'\nimport { Atom } from './declareAtom'\nimport { PayloadActionCreator } from './declareAction'\n\nexport { TreeId }\nexport type GenId = (name: string | [string] | symbol) => TreeId\nexport const TREE = Symbol('@@Reatom/TREE')\n\nexport type Unit = { [TREE]: Tree }\n\nexport type NonUndefined<T> = Exclude<T, undefined>\n\n/**\n * Helper for retrieving the data type used in an atom or action\n * @example\n * type MyAtomType = InferType<typeof myAtom>\n * type MyActionType = InferType<typeof myAction>\n */\nexport type InferType<T> = T extends\n  | Atom<infer R>\n  | PayloadActionCreator<infer R>\n  ? R\n  : never\n\nexport function noop() {}\n\n// eslint-disable-next-line prefer-destructuring\nexport const assign = Object.assign\n\nexport const equals = Object.is\n\nexport function getTree(thing: Unit): Tree {\n  return thing && thing[TREE]\n}\n\nexport function getName(treeId: TreeId): string {\n  return typeof treeId === 'symbol'\n    ? treeId.description || treeId.toString().replace(/Symbol\\((.*)\\)/, '$1')\n    : treeId\n}\n\nexport function getIsAtom(thing: any): thing is Atom<any> {\n  const vertex = getTree(thing)\n  return Boolean(vertex && !vertex.isLeaf)\n}\n\nexport function getIsAction(thing: any): thing is Atom<any> {\n  const vertex = getTree(thing)\n  return Boolean(vertex && vertex.isLeaf)\n}\n\nlet id = 0\nexport function nameToIdDefault(name: string | [string] | symbol): TreeId {\n  return typeof name === 'symbol'\n    ? // TODO: https://github.com/microsoft/TypeScript/issues/1863\n      ((name as unknown) as string)\n    : Array.isArray(name)\n    ? safetyStr(name[0], 'name')\n    : `${safetyStr(name, 'name')} [${++id}]`\n}\nlet _nameToId: GenId\nexport function nameToId(name: string | [string] | symbol): TreeId {\n  return _nameToId ? _nameToId(name) : nameToIdDefault(name)\n}\n\nexport function setNameToId(gen: GenId) {\n  _nameToId = safetyFunc(gen, 'gen')\n}\n\nexport function throwError(error: string) {\n  // TODO: add link to docs with full description\n  throw new Error(`[reatom] ${error}`)\n}\nexport function safetyStr(str: string, name: string): string {\n  if (typeof str !== 'string' || str.length === 0) throwError(`Invalid ${name}`)\n  return str\n}\nexport function safetyFunc<T extends Function>(\n  func: T | undefined,\n  name: string,\n): T {\n  if (typeof func !== 'function') throwError(`Invalid ${name}`)\n  return func as T\n}\n\nexport function getOwnKeys<T extends object>(obj: T): Array<keyof T> {\n  const keys = Object.keys(obj) as Array<keyof T>\n  keys.push(...(Object.getOwnPropertySymbols(obj) as Array<keyof T>))\n\n  return keys\n}\n","import { Leaf, Tree, BaseAction } from './kernel'\nimport { TREE, nameToId, Unit } from './shared'\nimport { Store } from './createStore'\n\nexport type ActionType = Leaf\nexport type Reaction<T> = (payload: T, store: Store) => any\n\nexport type Action<Payload, Type extends ActionType = string> = BaseAction<\n  Payload\n> & {\n  type: Type\n  reactions?: Reaction<Payload>[]\n}\n\nexport type BaseActionCreator<Type extends string = string> = {\n  getType: () => Type\n} & Unit\n\nexport type ActionCreator<Type extends string = string> = BaseActionCreator<\n  Type\n> &\n  (() => Action<undefined, Type>)\n\nexport type PayloadActionCreator<\n  Payload,\n  Type extends string = string\n> = BaseActionCreator<Type> & ((payload: Payload) => Action<Payload, Type>)\n\nexport function declareAction(\n  name?: string | Reaction<undefined>,\n  ...reactions: Reaction<undefined>[]\n): ActionCreator<string>\n\nexport function declareAction<Type extends ActionType>(\n  name: [Type],\n  ...reactions: Reaction<undefined>[]\n): ActionCreator<Type>\n\nexport function declareAction<Payload>(\n  name?: string | Reaction<Payload>,\n  ...reactions: Reaction<Payload>[]\n): PayloadActionCreator<Payload, string>\n\nexport function declareAction<Payload, Type extends ActionType>(\n  name: [Type],\n  ...reactions: Reaction<Payload>[]\n): PayloadActionCreator<Payload, Type>\n\nexport function declareAction<\n  Payload = undefined,\n  Type extends ActionType = string\n>(\n  name: string | [Type] | Reaction<Payload> = 'action',\n  ...reactions: Reaction<Payload>[]\n): ActionCreator<Type> | PayloadActionCreator<Payload, Type> {\n  if (typeof name === 'function') {\n    reactions.unshift(name)\n    name = 'action'\n  }\n  const id = nameToId(name)\n\n  const ACTree = new Tree(id, true)\n\n  const actionCreator = function actionCreator(payload?: Payload) {\n    return {\n      type: id,\n      payload,\n      reactions,\n    }\n  } as ActionCreator<Type> | PayloadActionCreator<Payload, Type>\n\n  actionCreator[TREE] = ACTree\n  actionCreator.getType = () => id as Type\n\n  return actionCreator\n}\n","import { Tree, State, TreeId, Ctx, createCtx, Leaf } from './kernel'\nimport {\n  TREE,\n  nameToId,\n  NonUndefined,\n  Unit,\n  throwError,\n  getTree,\n  safetyFunc,\n  getIsAction,\n  assign,\n  getName,\n  equals,\n  getOwnKeys,\n} from './shared'\nimport { Action, declareAction, PayloadActionCreator } from './declareAction'\n\nconst DEPS = Symbol('@@Reatom/DEPS')\nconst DEPS_SHAPE = Symbol('@@Reatom/DEPS_SHAPE')\n\n// action for set initialState of each atom to global state\nexport const init = declareAction(['@@Reatom/init'])\nexport const initAction = init()\n\ntype AtomName = TreeId | [string]\ntype AtomsMap = { [key: string]: Atom<any> }\ntype Reducer<TState, TValue> = (state: TState, value: TValue) => TState\n\n/**\n * This interface needed for correct type inference with TypeScript 3.5\n * @see https://github.com/artalar/reatom/issues/301\n */\ninterface DependencyMatcherOn<TState> {\n  <T>(dependency: Atom<T>, reducer: Reducer<TState, T>): void\n  <T>(dependency: PayloadActionCreator<T>, reducer: Reducer<TState, T>): void\n  <T>(\n    dependency: Atom<T> | PayloadActionCreator<T>,\n    reducer: Reducer<TState, T>,\n  ): void\n}\ntype DependencyMatcher<TState> = (on: DependencyMatcherOn<TState>) => any\n\nexport interface Atom<T> extends Unit {\n  (state?: State, action?: Action<any>): Record<string, T | any>\n  [DEPS]: Set<TreeId>\n  [DEPS_SHAPE]?: AtomsMap | TupleOfAtoms\n}\n\nexport function declareAtom<TState>(\n  initialState: TState,\n  dependencyMatcher: DependencyMatcher<TState>,\n): Atom<TState>\nexport function declareAtom<TState>(\n  name: AtomName,\n  initialState: TState,\n  dependencyMatcher: DependencyMatcher<TState>,\n): Atom<TState>\nexport function declareAtom<TState>(\n  name: AtomName | TState,\n  initialState: TState | DependencyMatcher<TState>,\n  dependencyMatcher?: DependencyMatcher<TState>,\n): Atom<TState> {\n  if (!dependencyMatcher) {\n    dependencyMatcher = initialState as DependencyMatcher<TState>\n    initialState = name as TState\n    name = 'atom'\n  }\n\n  const _id = nameToId(name as AtomName)\n  const _name = getName(_id)\n\n  if (initialState === undefined)\n    throwError(`Atom \"${_name}\". Initial state can't be undefined`)\n\n  const _tree = new Tree(_id)\n  const _deps = new Set<TreeId>()\n  // start from `0` for missing `actionDefault`\n  let dependencePosition = 0\n  const initialPhase = true\n\n  function on<T>(\n    dep: Unit | PayloadActionCreator<T>,\n    reducer: Reducer<TState, T>,\n  ) {\n    if (!initialPhase)\n      throwError(\"Can't define dependencies after atom initialization\")\n\n    safetyFunc(reducer, 'reducer')\n\n    const position = dependencePosition++\n    const depTree = getTree(dep as Unit)\n    if (!depTree) throwError('Invalid dependency')\n    const depId = depTree.id\n\n    const isDepActionCreator = getIsAction(dep)\n\n    _tree.union(depTree)\n\n    const update = function update({\n      state,\n      stateNew,\n      payload,\n      changedIds,\n      type,\n    }: Ctx) {\n      const atomStateSnapshot = state[_id as string]\n      // first `walk` of lazy (dynamically added by subscription) atom\n      const isAtomLazy = atomStateSnapshot === undefined\n\n      if (!isAtomLazy && type === initAction.type && !payload) return\n\n      const atomStatePreviousReducer = stateNew[_id as string]\n      // it is mean atom has more than one dependencies\n      // that depended from dispatched action\n      // and one of the atom reducers already processed\n      const hasAtomNewState = atomStatePreviousReducer !== undefined\n      const atomState = (hasAtomNewState\n        ? atomStatePreviousReducer\n        : atomStateSnapshot) as TState\n\n      const depStateSnapshot = state[depId as string]\n      const depStateNew = stateNew[depId as string]\n      const isDepChanged = depStateNew !== undefined\n      const depState = isDepChanged ? depStateNew : depStateSnapshot\n      const depValue = isDepActionCreator ? payload : depState\n\n      if (isDepActionCreator || isDepChanged || isAtomLazy) {\n        const atomStateNew = reducer(atomState, depValue)\n\n        if (atomStateNew === undefined)\n          throwError(\n            `Invalid state. Reducer number ${position} in \"${_name}\" atom returns undefined`,\n          )\n\n        if (hasAtomNewState && equals(atomStateSnapshot, atomStateNew)) {\n          changedIds.splice(changedIds.indexOf(_id), 1)\n          delete stateNew[_id as string]\n\n          return\n        }\n\n        if (!equals(atomState, atomStateNew)) {\n          if (!hasAtomNewState) changedIds.push(_id)\n\n          stateNew[_id as string] = atomStateNew\n        }\n      }\n    }\n    update._ownerAtomId = _id\n\n    if (isDepActionCreator) return _tree.addFn(update, depId as Leaf)\n    if (_deps.has(depId)) throwError('One of dependencies has the equal id')\n    _deps.add(depId)\n    depTree.fnsMap.forEach((_, key) => _tree.addFn(update, key))\n  }\n\n  on(init, (_, { [_id]: state = initialState }: any = {}) => state)\n  dependencyMatcher(on)\n\n  const atom = function atom(\n    state: State = {},\n    action: Action<any> = initAction,\n  ) {\n    const ctx = createCtx(state, action)\n    _tree.forEach(action.type, ctx)\n\n    const { changedIds, stateNew } = ctx\n\n    return changedIds.length > 0 ? assign({}, state, stateNew) : state\n  } as Atom<TState>\n\n  atom[TREE] = _tree\n  atom[DEPS] = _deps\n\n  return atom\n}\n\nexport function getState<T>(state: State, atom: Atom<T>): T | undefined {\n  return state[atom[TREE].id as string] as T | undefined\n}\n\nexport function map<T, TSource = unknown>(\n  source: Atom<TSource>,\n  mapper: (dependedAtomState: TSource) => NonUndefined<T>,\n): Atom<T>\nexport function map<T, TSource = unknown>(\n  name: AtomName,\n  source: Atom<TSource>,\n  mapper: (dependedAtomState: TSource) => NonUndefined<T>,\n): Atom<T>\nexport function map<T, TSource = unknown>(\n  name: AtomName | Atom<TSource>,\n  source: ((dependedAtomState: TSource) => T) | Atom<TSource>,\n  mapper?: (dependedAtomState: TSource) => NonUndefined<T>,\n) {\n  if (!mapper) {\n    mapper = source as (dependedAtomState: TSource) => NonUndefined<T>\n    source = name as Atom<TSource>\n    name = Symbol(`${getName(getTree(source).id)} [map]`)\n  }\n  safetyFunc(mapper, 'mapper')\n\n  return declareAtom<T>(\n    name as AtomName,\n    // FIXME: initialState for `map` :thinking:\n    null as any,\n    handle =>\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      handle(source as Atom<TSource>, (state, payload) => mapper!(payload)),\n  )\n}\n\ntype TupleOfAtoms = [Atom<unknown>] | Atom<unknown>[]\n\nexport function combine<T extends AtomsMap | TupleOfAtoms>(\n  shape: T,\n): Atom<{ [key in keyof T]: T[key] extends Atom<infer S> ? S : never }>\nexport function combine<T extends AtomsMap | TupleOfAtoms>(\n  name: AtomName,\n  shape: T,\n): Atom<{ [key in keyof T]: T[key] extends Atom<infer S> ? S : never }>\nexport function combine<T extends AtomsMap | TupleOfAtoms>(\n  name: AtomName | T,\n  shape?: T,\n) {\n  if (arguments.length === 1) shape = name as T\n\n  const isArray = Array.isArray(shape)\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const keys = getOwnKeys(shape!) as TreeId[]\n\n  if (arguments.length === 1)\n    name = isArray\n      ? Symbol(\n          `[${keys\n            .map(k => getName(getTree((shape as TupleOfAtoms)[k as any]).id))\n            .join()}]`,\n        )\n      : Symbol(`{${keys.map(getName).join()}}`)\n\n  const atom = declareAtom(name as AtomName, isArray ? [] : {}, reduce =>\n    keys.forEach(key =>\n      reduce((shape as any)[key], (state, payload) => {\n        const newState: any = isArray\n          ? (state as any[]).slice(0)\n          : assign({}, state)\n        newState[key] = payload\n        return newState\n      }),\n    ),\n  )\n  atom[DEPS_SHAPE] = shape\n  return atom\n}\n\nexport function getDepsShape(\n  thing: Atom<any>,\n): AtomsMap | TupleOfAtoms | undefined {\n  return thing[DEPS_SHAPE]\n}\n","import { Tree, State, TreeId, createCtx, BaseAction } from './kernel'\nimport {\n  throwError,\n  getTree,\n  safetyFunc,\n  assign,\n  getIsAtom,\n  getIsAction,\n  getOwnKeys,\n} from './shared'\nimport { Action, PayloadActionCreator } from './declareAction'\nimport { Atom, initAction, getState } from './declareAtom'\n\ntype ActionsSubscriber = (action: Action<unknown>, stateDiff: State) => any\ntype SubscribeFunction = {\n  <T>(\n    target: Atom<T> | PayloadActionCreator<T>,\n    listener: (state: T) => any,\n  ): () => void\n  (listener: ActionsSubscriber): () => void\n}\ntype GetStateFunction = {\n  <T>(target: Atom<T>): T\n  (): State\n}\n\nexport type Store = {\n  dispatch: <T>(action: Action<T>) => void\n  subscribe: SubscribeFunction\n  getState: GetStateFunction\n  bind: <A extends (...a: any[]) => BaseAction>(\n    a: A,\n  ) => (...a: A extends (...a: infer Args) => any ? Args : never) => void\n}\n\nexport function createStore(initState?: State): Store\nexport function createStore(atom: Atom<any>, initState?: State): Store\n// TODO: try to use ES6 Map's instead of plain object\n// for prevent using `delete` operator\n// (need perf tests)\nexport function createStore(\n  atom?: Atom<any> | State,\n  initState?: State,\n): Store {\n  let listeners: Map<TreeId, Function[]> = new Map<TreeId, Function[]>()\n  let nextListeners: Map<TreeId, Function[]> = listeners\n  let dispatchListeners: Function[] = []\n  let nextDispatchListeners: Function[] = dispatchListeners\n  let initialAtoms = new Set<TreeId>()\n  let state: State = {}\n  const storeTree = new Tree('store')\n  if (atom !== undefined) {\n    if (typeof atom === 'object' && initState === undefined) assign(state, atom)\n    else {\n      if (!getIsAtom(atom)) throwError('Invalid atom')\n      if (typeof initState === 'object' && initState !== null)\n        assign(state, initState)\n      else if (initState !== undefined) throwError('Invalid initial state')\n\n      storeTree.union(getTree(atom as Atom<any>))\n      const ctx = createCtx(state, initAction)\n      storeTree.forEach(initAction.type, ctx)\n      assign(state, ctx.stateNew)\n      initialAtoms = new Set(getOwnKeys(ctx.stateNew))\n    }\n  }\n\n  function ensureCanMutateNextDispatchListeners() {\n    if (nextDispatchListeners === dispatchListeners) {\n      nextDispatchListeners = dispatchListeners.slice()\n    }\n  }\n\n  function ensureCanMutateNextListeners(treeId: TreeId) {\n    if (nextListeners === listeners) {\n      nextListeners = new Map()\n      listeners.forEach((value, key) =>\n        nextListeners.set(key, treeId === key ? value.slice() : value),\n      )\n    }\n  }\n\n  function _getState(): State\n  function _getState<T>(target?: Atom<T>): State | T {\n    // TODO: try to cache `assign`\n    if (target === undefined) return assign({}, state) as State\n\n    if (!getIsAtom(target)) throwError('Invalid target')\n\n    const targetState = getState<T>(state, target)\n    if (targetState !== undefined) return targetState\n\n    const ctx = createCtx(state, initAction)\n    getTree(target).forEach(initAction.type, ctx)\n\n    return getState(ctx.stateNew, target)\n  }\n\n  function subscribe(subscriber: ActionsSubscriber): () => void\n  function subscribe<T>(\n    target: Atom<T> | PayloadActionCreator<T>,\n    subscriber: (state: T) => any,\n  ): () => void\n  function subscribe<T>(\n    target: Atom<T> | PayloadActionCreator<T> | ActionsSubscriber,\n    subscriber?: (state: T) => any,\n  ): () => void {\n    const listener = safetyFunc(subscriber || target, 'listener')\n    let isSubscribed = true\n\n    if (subscriber === undefined) {\n      if (getIsAtom(listener) || getIsAction(listener))\n        throwError('Invalid listener')\n\n      ensureCanMutateNextDispatchListeners()\n      nextDispatchListeners.push(listener)\n      return () => {\n        if (!isSubscribed) return\n        isSubscribed = false\n        ensureCanMutateNextDispatchListeners()\n        nextDispatchListeners.splice(nextDispatchListeners.indexOf(listener), 1)\n      }\n    }\n\n    const isAction = getIsAction(target)\n    if (!getIsAtom(target) && !isAction)\n      throwError('Invalid subscription target')\n    const targetTree = getTree(target as Atom<T> | PayloadActionCreator<T>)\n    const targetId = targetTree.id\n    const isLazy = !isAction && !initialAtoms.has(targetId)\n\n    ensureCanMutateNextListeners(targetId)\n    if (!nextListeners.has(targetId)) {\n      nextListeners.set(targetId, [])\n      if (isLazy) {\n        storeTree.union(targetTree)\n        const ctx = createCtx(state, initAction)\n        targetTree.forEach(initAction.type, ctx)\n        assign(state, ctx.stateNew)\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    nextListeners.get(targetId)!.push(listener)\n\n    return () => {\n      if (!isSubscribed) return\n      isSubscribed = false\n\n      ensureCanMutateNextListeners(targetId)\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const _listeners = nextListeners.get(targetId)!\n      _listeners.splice(_listeners.indexOf(listener), 1)\n\n      if (isLazy && _listeners.length === 0) {\n        nextListeners.delete(targetId)\n        storeTree.disunion(targetTree, id => {\n          delete state[id as string]\n        })\n      }\n    }\n  }\n\n  function dispatch(action: Action<any>) {\n    const { type, payload, reactions } = action\n    if (\n      typeof action !== 'object' ||\n      action === null ||\n      typeof type !== 'string'\n    )\n      throwError('Invalid action')\n\n    const ctx = createCtx(state, action)\n    storeTree.forEach(type, ctx)\n\n    const { changedIds, stateNew } = ctx\n\n    listeners = nextListeners\n\n    if (type === initAction.type) state = payload || {}\n    if (changedIds.length > 0) {\n      assign(state, stateNew)\n      for (let i = 0; i < changedIds.length; i++) {\n        const id = changedIds[i]\n        callFromList(listeners.get(id) || [], stateNew[id as string])\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    callFromList(reactions || [], payload, store)\n    callFromList(listeners.get(type) || [], payload)\n    callFromList((dispatchListeners = nextDispatchListeners), action, stateNew)\n  }\n\n  const bind: Store['bind'] = actionCreator => (...a) =>\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    store.dispatch(actionCreator(...a))\n\n  const store = {\n    getState: _getState,\n    subscribe,\n    dispatch,\n    bind,\n  }\n\n  return store\n}\n\nfunction callFromList(list: Function[], ...arg: any[]) {\n  let i = -1\n  while (++i < list.length) list[i](...arg)\n}\n"],"names":["createCtx","state","type","payload","stateNew","changedIds","SetCounted","constructor","this","Map","add","el","_counter","set","get","delete","count","forEach","cb","_","fn","Tree","id","isLeaf","fnsMap","_getFns","key","addFn","union","tree","fns","disunion","_ownerAtomId","ctx","setCounted","TREE","Symbol","noop","assign","Object","equals","is","getTree","thing","getName","treeId","description","toString","replace","getIsAtom","vertex","Boolean","getIsAction","_nameToId","nameToIdDefault","name","Array","isArray","safetyStr","nameToId","setNameToId","gen","safetyFunc","throwError","error","Error","str","length","func","getOwnKeys","obj","keys","push","getOwnPropertySymbols","declareAction","reactions","unshift","ACTree","actionCreator","getType","DEPS","DEPS_SHAPE","init","initAction","declareAtom","initialState","dependencyMatcher","_id","_name","undefined","_tree","_deps","Set","dependencePosition","on","dep","reducer","position","depTree","depId","isDepActionCreator","update","atomStateSnapshot","isAtomLazy","atomStatePreviousReducer","hasAtomNewState","atomState","depStateNew","isDepChanged","atomStateNew","splice","indexOf","has","[object Object]","atom","action","getState","map","source","mapper","handle","combine","shape","arguments","k","join","reduce","newState","slice","getDepsShape","createStore","initState","listeners","nextListeners","dispatchListeners","nextDispatchListeners","initialAtoms","storeTree","ensureCanMutateNextDispatchListeners","ensureCanMutateNextListeners","value","store","target","targetState","subscribe","subscriber","listener","isSubscribed","isAction","targetTree","targetId","isLazy","_listeners","dispatch","i","callFromList","bind","a","list","arg"],"mappings":"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"}