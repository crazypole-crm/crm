{"version":3,"file":"index.js","sources":["../src/kernel.ts","../src/shared.ts","../src/declareAction.ts","../src/declareAtom.ts","../src/createStore.ts"],"sourcesContent":["export type Leaf = string // unique\nexport type TreeId = string | symbol // unique\nexport type State = Record<TreeId, unknown>\n// reatom specific\nexport type Fn = {\n  (ctx: Ctx): any\n  _ownerAtomId: TreeId\n}\nexport type Ctx = ReturnType<typeof createCtx>\nexport type BaseAction<T = any> = { type: Leaf; payload: T }\nexport function createCtx(state: State, { type, payload }: BaseAction) {\n  return {\n    state,\n    stateNew: {} as State,\n    type,\n    payload,\n    changedIds: [] as TreeId[],\n  }\n}\n\nclass SetCounted {\n  _counter = new Map<Fn, number>()\n\n  add(el: Fn) {\n    this._counter.set(el, (this._counter.get(el) || 0) + 1)\n  }\n\n  delete(el: Fn) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const count = this._counter.get(el)!\n    if (count === 1) {\n      return this._counter.delete(el)\n    }\n    if (count > 1) {\n      this._counter.set(el, count - 1)\n    }\n    return false\n  }\n\n  forEach(cb: (fn: Fn) => any) {\n    this._counter.forEach((_, fn) => cb(fn))\n  }\n}\n\nexport class Tree {\n  id: TreeId\n\n  isLeaf: boolean\n\n  fnsMap: Map<Leaf, SetCounted>\n\n  constructor(id: TreeId, isLeaf = false) {\n    this.id = id\n    this.isLeaf = isLeaf\n    this.fnsMap = new Map()\n  }\n\n  _getFns(key: Leaf) {\n    return (\n      this.fnsMap.get(key) ||\n      (this.fnsMap.set(key, new SetCounted()).get(key) as SetCounted)\n    )\n  }\n\n  addFn(fn: Fn, key: Leaf) {\n    this._getFns(key).add(fn)\n  }\n\n  union(tree: Tree) {\n    tree.fnsMap.forEach((set, key) => {\n      const fns = this._getFns(key)\n      set.forEach(fn => fns.add(fn))\n    })\n  }\n\n  disunion(tree: Tree, cb: (key: TreeId) => any) {\n    tree.fnsMap.forEach((set, key) => {\n      const fns = this._getFns(key)\n      set.forEach(fn => fns.delete(fn) && cb(fn._ownerAtomId))\n    })\n  }\n\n  forEach(key: Leaf, ctx: Ctx) {\n    const setCounted = this.fnsMap.get(key)\n    if (setCounted) setCounted.forEach(fn => fn(ctx))\n  }\n}\n","import { Tree, TreeId } from './kernel'\nimport { Atom } from './declareAtom'\nimport { PayloadActionCreator } from './declareAction'\n\nexport { TreeId }\nexport type GenId = (name: string | [string] | symbol) => TreeId\nexport const TREE = Symbol('@@Reatom/TREE')\n\nexport type Unit = { [TREE]: Tree }\n\nexport type NonUndefined<T> = Exclude<T, undefined>\n\n/**\n * Helper for retrieving the data type used in an atom or action\n * @example\n * type MyAtomType = InferType<typeof myAtom>\n * type MyActionType = InferType<typeof myAction>\n */\nexport type InferType<T> = T extends\n  | Atom<infer R>\n  | PayloadActionCreator<infer R>\n  ? R\n  : never\n\nexport function noop() {}\n\n// eslint-disable-next-line prefer-destructuring\nexport const assign = Object.assign\n\nexport const equals = Object.is\n\nexport function getTree(thing: Unit): Tree {\n  return thing && thing[TREE]\n}\n\nexport function getName(treeId: TreeId): string {\n  return typeof treeId === 'symbol'\n    ? treeId.description || treeId.toString().replace(/Symbol\\((.*)\\)/, '$1')\n    : treeId\n}\n\nexport function getIsAtom(thing: any): thing is Atom<any> {\n  const vertex = getTree(thing)\n  return Boolean(vertex && !vertex.isLeaf)\n}\n\nexport function getIsAction(thing: any): thing is Atom<any> {\n  const vertex = getTree(thing)\n  return Boolean(vertex && vertex.isLeaf)\n}\n\nlet id = 0\nexport function nameToIdDefault(name: string | [string] | symbol): TreeId {\n  return typeof name === 'symbol'\n    ? // TODO: https://github.com/microsoft/TypeScript/issues/1863\n      ((name as unknown) as string)\n    : Array.isArray(name)\n    ? safetyStr(name[0], 'name')\n    : `${safetyStr(name, 'name')} [${++id}]`\n}\nlet _nameToId: GenId\nexport function nameToId(name: string | [string] | symbol): TreeId {\n  return _nameToId ? _nameToId(name) : nameToIdDefault(name)\n}\n\nexport function setNameToId(gen: GenId) {\n  _nameToId = safetyFunc(gen, 'gen')\n}\n\nexport function throwError(error: string) {\n  // TODO: add link to docs with full description\n  throw new Error(`[reatom] ${error}`)\n}\nexport function safetyStr(str: string, name: string): string {\n  if (typeof str !== 'string' || str.length === 0) throwError(`Invalid ${name}`)\n  return str\n}\nexport function safetyFunc<T extends Function>(\n  func: T | undefined,\n  name: string,\n): T {\n  if (typeof func !== 'function') throwError(`Invalid ${name}`)\n  return func as T\n}\n\nexport function getOwnKeys<T extends object>(obj: T): Array<keyof T> {\n  const keys = Object.keys(obj) as Array<keyof T>\n  keys.push(...(Object.getOwnPropertySymbols(obj) as Array<keyof T>))\n\n  return keys\n}\n","import { Leaf, Tree, BaseAction } from './kernel'\nimport { TREE, nameToId, Unit } from './shared'\nimport { Store } from './createStore'\n\nexport type ActionType = Leaf\nexport type Reaction<T> = (payload: T, store: Store) => any\n\nexport type Action<Payload, Type extends ActionType = string> = BaseAction<\n  Payload\n> & {\n  type: Type\n  reactions?: Reaction<Payload>[]\n}\n\nexport type BaseActionCreator<Type extends string = string> = {\n  getType: () => Type\n} & Unit\n\nexport type ActionCreator<Type extends string = string> = BaseActionCreator<\n  Type\n> &\n  (() => Action<undefined, Type>)\n\nexport type PayloadActionCreator<\n  Payload,\n  Type extends string = string\n> = BaseActionCreator<Type> & ((payload: Payload) => Action<Payload, Type>)\n\nexport function declareAction(\n  name?: string | Reaction<undefined>,\n  ...reactions: Reaction<undefined>[]\n): ActionCreator<string>\n\nexport function declareAction<Type extends ActionType>(\n  name: [Type],\n  ...reactions: Reaction<undefined>[]\n): ActionCreator<Type>\n\nexport function declareAction<Payload>(\n  name?: string | Reaction<Payload>,\n  ...reactions: Reaction<Payload>[]\n): PayloadActionCreator<Payload, string>\n\nexport function declareAction<Payload, Type extends ActionType>(\n  name: [Type],\n  ...reactions: Reaction<Payload>[]\n): PayloadActionCreator<Payload, Type>\n\nexport function declareAction<\n  Payload = undefined,\n  Type extends ActionType = string\n>(\n  name: string | [Type] | Reaction<Payload> = 'action',\n  ...reactions: Reaction<Payload>[]\n): ActionCreator<Type> | PayloadActionCreator<Payload, Type> {\n  if (typeof name === 'function') {\n    reactions.unshift(name)\n    name = 'action'\n  }\n  const id = nameToId(name)\n\n  const ACTree = new Tree(id, true)\n\n  const actionCreator = function actionCreator(payload?: Payload) {\n    return {\n      type: id,\n      payload,\n      reactions,\n    }\n  } as ActionCreator<Type> | PayloadActionCreator<Payload, Type>\n\n  actionCreator[TREE] = ACTree\n  actionCreator.getType = () => id as Type\n\n  return actionCreator\n}\n","import { Tree, State, TreeId, Ctx, createCtx, Leaf } from './kernel'\nimport {\n  TREE,\n  nameToId,\n  NonUndefined,\n  Unit,\n  throwError,\n  getTree,\n  safetyFunc,\n  getIsAction,\n  assign,\n  getName,\n  equals,\n  getOwnKeys,\n} from './shared'\nimport { Action, declareAction, PayloadActionCreator } from './declareAction'\n\nconst DEPS = Symbol('@@Reatom/DEPS')\nconst DEPS_SHAPE = Symbol('@@Reatom/DEPS_SHAPE')\n\n// action for set initialState of each atom to global state\nexport const init = declareAction(['@@Reatom/init'])\nexport const initAction = init()\n\ntype AtomName = TreeId | [string]\ntype AtomsMap = { [key: string]: Atom<any> }\ntype Reducer<TState, TValue> = (state: TState, value: TValue) => TState\n\n/**\n * This interface needed for correct type inference with TypeScript 3.5\n * @see https://github.com/artalar/reatom/issues/301\n */\ninterface DependencyMatcherOn<TState> {\n  <T>(dependency: Atom<T>, reducer: Reducer<TState, T>): void\n  <T>(dependency: PayloadActionCreator<T>, reducer: Reducer<TState, T>): void\n  <T>(\n    dependency: Atom<T> | PayloadActionCreator<T>,\n    reducer: Reducer<TState, T>,\n  ): void\n}\ntype DependencyMatcher<TState> = (on: DependencyMatcherOn<TState>) => any\n\nexport interface Atom<T> extends Unit {\n  (state?: State, action?: Action<any>): Record<string, T | any>\n  [DEPS]: Set<TreeId>\n  [DEPS_SHAPE]?: AtomsMap | TupleOfAtoms\n}\n\nexport function declareAtom<TState>(\n  initialState: TState,\n  dependencyMatcher: DependencyMatcher<TState>,\n): Atom<TState>\nexport function declareAtom<TState>(\n  name: AtomName,\n  initialState: TState,\n  dependencyMatcher: DependencyMatcher<TState>,\n): Atom<TState>\nexport function declareAtom<TState>(\n  name: AtomName | TState,\n  initialState: TState | DependencyMatcher<TState>,\n  dependencyMatcher?: DependencyMatcher<TState>,\n): Atom<TState> {\n  if (!dependencyMatcher) {\n    dependencyMatcher = initialState as DependencyMatcher<TState>\n    initialState = name as TState\n    name = 'atom'\n  }\n\n  const _id = nameToId(name as AtomName)\n  const _name = getName(_id)\n\n  if (initialState === undefined)\n    throwError(`Atom \"${_name}\". Initial state can't be undefined`)\n\n  const _tree = new Tree(_id)\n  const _deps = new Set<TreeId>()\n  // start from `0` for missing `actionDefault`\n  let dependencePosition = 0\n  const initialPhase = true\n\n  function on<T>(\n    dep: Unit | PayloadActionCreator<T>,\n    reducer: Reducer<TState, T>,\n  ) {\n    if (!initialPhase)\n      throwError(\"Can't define dependencies after atom initialization\")\n\n    safetyFunc(reducer, 'reducer')\n\n    const position = dependencePosition++\n    const depTree = getTree(dep as Unit)\n    if (!depTree) throwError('Invalid dependency')\n    const depId = depTree.id\n\n    const isDepActionCreator = getIsAction(dep)\n\n    _tree.union(depTree)\n\n    const update = function update({\n      state,\n      stateNew,\n      payload,\n      changedIds,\n      type,\n    }: Ctx) {\n      const atomStateSnapshot = state[_id as string]\n      // first `walk` of lazy (dynamically added by subscription) atom\n      const isAtomLazy = atomStateSnapshot === undefined\n\n      if (!isAtomLazy && type === initAction.type && !payload) return\n\n      const atomStatePreviousReducer = stateNew[_id as string]\n      // it is mean atom has more than one dependencies\n      // that depended from dispatched action\n      // and one of the atom reducers already processed\n      const hasAtomNewState = atomStatePreviousReducer !== undefined\n      const atomState = (hasAtomNewState\n        ? atomStatePreviousReducer\n        : atomStateSnapshot) as TState\n\n      const depStateSnapshot = state[depId as string]\n      const depStateNew = stateNew[depId as string]\n      const isDepChanged = depStateNew !== undefined\n      const depState = isDepChanged ? depStateNew : depStateSnapshot\n      const depValue = isDepActionCreator ? payload : depState\n\n      if (isDepActionCreator || isDepChanged || isAtomLazy) {\n        const atomStateNew = reducer(atomState, depValue)\n\n        if (atomStateNew === undefined)\n          throwError(\n            `Invalid state. Reducer number ${position} in \"${_name}\" atom returns undefined`,\n          )\n\n        if (hasAtomNewState && equals(atomStateSnapshot, atomStateNew)) {\n          changedIds.splice(changedIds.indexOf(_id), 1)\n          delete stateNew[_id as string]\n\n          return\n        }\n\n        if (!equals(atomState, atomStateNew)) {\n          if (!hasAtomNewState) changedIds.push(_id)\n\n          stateNew[_id as string] = atomStateNew\n        }\n      }\n    }\n    update._ownerAtomId = _id\n\n    if (isDepActionCreator) return _tree.addFn(update, depId as Leaf)\n    if (_deps.has(depId)) throwError('One of dependencies has the equal id')\n    _deps.add(depId)\n    depTree.fnsMap.forEach((_, key) => _tree.addFn(update, key))\n  }\n\n  on(init, (_, { [_id]: state = initialState }: any = {}) => state)\n  dependencyMatcher(on)\n\n  const atom = function atom(\n    state: State = {},\n    action: Action<any> = initAction,\n  ) {\n    const ctx = createCtx(state, action)\n    _tree.forEach(action.type, ctx)\n\n    const { changedIds, stateNew } = ctx\n\n    return changedIds.length > 0 ? assign({}, state, stateNew) : state\n  } as Atom<TState>\n\n  atom[TREE] = _tree\n  atom[DEPS] = _deps\n\n  return atom\n}\n\nexport function getState<T>(state: State, atom: Atom<T>): T | undefined {\n  return state[atom[TREE].id as string] as T | undefined\n}\n\nexport function map<T, TSource = unknown>(\n  source: Atom<TSource>,\n  mapper: (dependedAtomState: TSource) => NonUndefined<T>,\n): Atom<T>\nexport function map<T, TSource = unknown>(\n  name: AtomName,\n  source: Atom<TSource>,\n  mapper: (dependedAtomState: TSource) => NonUndefined<T>,\n): Atom<T>\nexport function map<T, TSource = unknown>(\n  name: AtomName | Atom<TSource>,\n  source: ((dependedAtomState: TSource) => T) | Atom<TSource>,\n  mapper?: (dependedAtomState: TSource) => NonUndefined<T>,\n) {\n  if (!mapper) {\n    mapper = source as (dependedAtomState: TSource) => NonUndefined<T>\n    source = name as Atom<TSource>\n    name = Symbol(`${getName(getTree(source).id)} [map]`)\n  }\n  safetyFunc(mapper, 'mapper')\n\n  return declareAtom<T>(\n    name as AtomName,\n    // FIXME: initialState for `map` :thinking:\n    null as any,\n    handle =>\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      handle(source as Atom<TSource>, (state, payload) => mapper!(payload)),\n  )\n}\n\ntype TupleOfAtoms = [Atom<unknown>] | Atom<unknown>[]\n\nexport function combine<T extends AtomsMap | TupleOfAtoms>(\n  shape: T,\n): Atom<{ [key in keyof T]: T[key] extends Atom<infer S> ? S : never }>\nexport function combine<T extends AtomsMap | TupleOfAtoms>(\n  name: AtomName,\n  shape: T,\n): Atom<{ [key in keyof T]: T[key] extends Atom<infer S> ? S : never }>\nexport function combine<T extends AtomsMap | TupleOfAtoms>(\n  name: AtomName | T,\n  shape?: T,\n) {\n  if (arguments.length === 1) shape = name as T\n\n  const isArray = Array.isArray(shape)\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const keys = getOwnKeys(shape!) as TreeId[]\n\n  if (arguments.length === 1)\n    name = isArray\n      ? Symbol(\n          `[${keys\n            .map(k => getName(getTree((shape as TupleOfAtoms)[k as any]).id))\n            .join()}]`,\n        )\n      : Symbol(`{${keys.map(getName).join()}}`)\n\n  const atom = declareAtom(name as AtomName, isArray ? [] : {}, reduce =>\n    keys.forEach(key =>\n      reduce((shape as any)[key], (state, payload) => {\n        const newState: any = isArray\n          ? (state as any[]).slice(0)\n          : assign({}, state)\n        newState[key] = payload\n        return newState\n      }),\n    ),\n  )\n  atom[DEPS_SHAPE] = shape\n  return atom\n}\n\nexport function getDepsShape(\n  thing: Atom<any>,\n): AtomsMap | TupleOfAtoms | undefined {\n  return thing[DEPS_SHAPE]\n}\n","import { Tree, State, TreeId, createCtx, BaseAction } from './kernel'\nimport {\n  throwError,\n  getTree,\n  safetyFunc,\n  assign,\n  getIsAtom,\n  getIsAction,\n  getOwnKeys,\n} from './shared'\nimport { Action, PayloadActionCreator } from './declareAction'\nimport { Atom, initAction, getState } from './declareAtom'\n\ntype ActionsSubscriber = (action: Action<unknown>, stateDiff: State) => any\ntype SubscribeFunction = {\n  <T>(\n    target: Atom<T> | PayloadActionCreator<T>,\n    listener: (state: T) => any,\n  ): () => void\n  (listener: ActionsSubscriber): () => void\n}\ntype GetStateFunction = {\n  <T>(target: Atom<T>): T\n  (): State\n}\n\nexport type Store = {\n  dispatch: <T>(action: Action<T>) => void\n  subscribe: SubscribeFunction\n  getState: GetStateFunction\n  bind: <A extends (...a: any[]) => BaseAction>(\n    a: A,\n  ) => (...a: A extends (...a: infer Args) => any ? Args : never) => void\n}\n\nexport function createStore(initState?: State): Store\nexport function createStore(atom: Atom<any>, initState?: State): Store\n// TODO: try to use ES6 Map's instead of plain object\n// for prevent using `delete` operator\n// (need perf tests)\nexport function createStore(\n  atom?: Atom<any> | State,\n  initState?: State,\n): Store {\n  let listeners: Map<TreeId, Function[]> = new Map<TreeId, Function[]>()\n  let nextListeners: Map<TreeId, Function[]> = listeners\n  let dispatchListeners: Function[] = []\n  let nextDispatchListeners: Function[] = dispatchListeners\n  let initialAtoms = new Set<TreeId>()\n  let state: State = {}\n  const storeTree = new Tree('store')\n  if (atom !== undefined) {\n    if (typeof atom === 'object' && initState === undefined) assign(state, atom)\n    else {\n      if (!getIsAtom(atom)) throwError('Invalid atom')\n      if (typeof initState === 'object' && initState !== null)\n        assign(state, initState)\n      else if (initState !== undefined) throwError('Invalid initial state')\n\n      storeTree.union(getTree(atom as Atom<any>))\n      const ctx = createCtx(state, initAction)\n      storeTree.forEach(initAction.type, ctx)\n      assign(state, ctx.stateNew)\n      initialAtoms = new Set(getOwnKeys(ctx.stateNew))\n    }\n  }\n\n  function ensureCanMutateNextDispatchListeners() {\n    if (nextDispatchListeners === dispatchListeners) {\n      nextDispatchListeners = dispatchListeners.slice()\n    }\n  }\n\n  function ensureCanMutateNextListeners(treeId: TreeId) {\n    if (nextListeners === listeners) {\n      nextListeners = new Map()\n      listeners.forEach((value, key) =>\n        nextListeners.set(key, treeId === key ? value.slice() : value),\n      )\n    }\n  }\n\n  function _getState(): State\n  function _getState<T>(target?: Atom<T>): State | T {\n    // TODO: try to cache `assign`\n    if (target === undefined) return assign({}, state) as State\n\n    if (!getIsAtom(target)) throwError('Invalid target')\n\n    const targetState = getState<T>(state, target)\n    if (targetState !== undefined) return targetState\n\n    const ctx = createCtx(state, initAction)\n    getTree(target).forEach(initAction.type, ctx)\n\n    return getState(ctx.stateNew, target)\n  }\n\n  function subscribe(subscriber: ActionsSubscriber): () => void\n  function subscribe<T>(\n    target: Atom<T> | PayloadActionCreator<T>,\n    subscriber: (state: T) => any,\n  ): () => void\n  function subscribe<T>(\n    target: Atom<T> | PayloadActionCreator<T> | ActionsSubscriber,\n    subscriber?: (state: T) => any,\n  ): () => void {\n    const listener = safetyFunc(subscriber || target, 'listener')\n    let isSubscribed = true\n\n    if (subscriber === undefined) {\n      if (getIsAtom(listener) || getIsAction(listener))\n        throwError('Invalid listener')\n\n      ensureCanMutateNextDispatchListeners()\n      nextDispatchListeners.push(listener)\n      return () => {\n        if (!isSubscribed) return\n        isSubscribed = false\n        ensureCanMutateNextDispatchListeners()\n        nextDispatchListeners.splice(nextDispatchListeners.indexOf(listener), 1)\n      }\n    }\n\n    const isAction = getIsAction(target)\n    if (!getIsAtom(target) && !isAction)\n      throwError('Invalid subscription target')\n    const targetTree = getTree(target as Atom<T> | PayloadActionCreator<T>)\n    const targetId = targetTree.id\n    const isLazy = !isAction && !initialAtoms.has(targetId)\n\n    ensureCanMutateNextListeners(targetId)\n    if (!nextListeners.has(targetId)) {\n      nextListeners.set(targetId, [])\n      if (isLazy) {\n        storeTree.union(targetTree)\n        const ctx = createCtx(state, initAction)\n        targetTree.forEach(initAction.type, ctx)\n        assign(state, ctx.stateNew)\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    nextListeners.get(targetId)!.push(listener)\n\n    return () => {\n      if (!isSubscribed) return\n      isSubscribed = false\n\n      ensureCanMutateNextListeners(targetId)\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const _listeners = nextListeners.get(targetId)!\n      _listeners.splice(_listeners.indexOf(listener), 1)\n\n      if (isLazy && _listeners.length === 0) {\n        nextListeners.delete(targetId)\n        storeTree.disunion(targetTree, id => {\n          delete state[id as string]\n        })\n      }\n    }\n  }\n\n  function dispatch(action: Action<any>) {\n    const { type, payload, reactions } = action\n    if (\n      typeof action !== 'object' ||\n      action === null ||\n      typeof type !== 'string'\n    )\n      throwError('Invalid action')\n\n    const ctx = createCtx(state, action)\n    storeTree.forEach(type, ctx)\n\n    const { changedIds, stateNew } = ctx\n\n    listeners = nextListeners\n\n    if (type === initAction.type) state = payload || {}\n    if (changedIds.length > 0) {\n      assign(state, stateNew)\n      for (let i = 0; i < changedIds.length; i++) {\n        const id = changedIds[i]\n        callFromList(listeners.get(id) || [], stateNew[id as string])\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    callFromList(reactions || [], payload, store)\n    callFromList(listeners.get(type) || [], payload)\n    callFromList((dispatchListeners = nextDispatchListeners), action, stateNew)\n  }\n\n  const bind: Store['bind'] = actionCreator => (...a) =>\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    store.dispatch(actionCreator(...a))\n\n  const store = {\n    getState: _getState,\n    subscribe,\n    dispatch,\n    bind,\n  }\n\n  return store\n}\n\nfunction callFromList(list: Function[], ...arg: any[]) {\n  let i = -1\n  while (++i < list.length) list[i](...arg)\n}\n"],"names":["createCtx","state","stateNew","type","payload","changedIds","SetCounted","this","Map","add","el","_counter","set","get","count","forEach","cb","_","fn","Tree","id","isLeaf","fnsMap","_getFns","key","addFn","union","tree","fns","_this","disunion","_this2","_ownerAtomId","ctx","setCounted","TREE","Symbol","assign","Object","equals","is","getTree","thing","getName","treeId","description","toString","replace","getIsAtom","vertex","Boolean","getIsAction","_nameToId","nameToIdDefault","name","Array","isArray","safetyStr","nameToId","throwError","error","Error","str","length","safetyFunc","func","getOwnKeys","obj","keys","push","getOwnPropertySymbols","declareAction","reactions","unshift","ACTree","actionCreator","getType","DEPS","DEPS_SHAPE","init","initAction","declareAtom","initialState","dependencyMatcher","_id","_name","undefined","_tree","_deps","Set","dependencePosition","on","dep","reducer","position","depTree","depId","isDepActionCreator","update","atomStateSnapshot","isAtomLazy","atomStatePreviousReducer","hasAtomNewState","atomState","depStateNew","isDepChanged","atomStateNew","splice","indexOf","has","atom","action","getState","callFromList","list","i","shape","arguments","map","k","join","reduce","newState","slice","initState","listeners","nextListeners","dispatchListeners","nextDispatchListeners","initialAtoms","storeTree","ensureCanMutateNextDispatchListeners","ensureCanMutateNextListeners","value","store","target","targetState","subscribe","subscriber","listener","isSubscribed","isAction","targetTree","targetId","isLazy","_listeners","dispatch","bind","source","mapper","handle","gen"],"mappings":"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"}