{"version":3,"file":"index.es.js","sources":["../src/kernel.ts","../src/shared.ts","../src/declareAction.ts","../src/declareAtom.ts","../src/createStore.ts"],"sourcesContent":["export type Leaf = string // unique\nexport type TreeId = string | symbol // unique\nexport type State = Record<TreeId, unknown>\n// reatom specific\nexport type Fn = {\n  (ctx: Ctx): any\n  _ownerAtomId: TreeId\n}\nexport type Ctx = ReturnType<typeof createCtx>\nexport type BaseAction<T = any> = { type: Leaf; payload: T }\nexport function createCtx(state: State, { type, payload }: BaseAction) {\n  return {\n    state,\n    stateNew: {} as State,\n    type,\n    payload,\n    changedIds: [] as TreeId[],\n  }\n}\n\nclass SetCounted {\n  _counter = new Map<Fn, number>()\n\n  add(el: Fn) {\n    this._counter.set(el, (this._counter.get(el) || 0) + 1)\n  }\n\n  delete(el: Fn) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const count = this._counter.get(el)!\n    if (count === 1) {\n      return this._counter.delete(el)\n    }\n    if (count > 1) {\n      this._counter.set(el, count - 1)\n    }\n    return false\n  }\n\n  forEach(cb: (fn: Fn) => any) {\n    this._counter.forEach((_, fn) => cb(fn))\n  }\n}\n\nexport class Tree {\n  id: TreeId\n\n  isLeaf: boolean\n\n  fnsMap: Map<Leaf, SetCounted>\n\n  constructor(id: TreeId, isLeaf = false) {\n    this.id = id\n    this.isLeaf = isLeaf\n    this.fnsMap = new Map()\n  }\n\n  _getFns(key: Leaf) {\n    return (\n      this.fnsMap.get(key) ||\n      (this.fnsMap.set(key, new SetCounted()).get(key) as SetCounted)\n    )\n  }\n\n  addFn(fn: Fn, key: Leaf) {\n    this._getFns(key).add(fn)\n  }\n\n  union(tree: Tree) {\n    tree.fnsMap.forEach((set, key) => {\n      const fns = this._getFns(key)\n      set.forEach(fn => fns.add(fn))\n    })\n  }\n\n  disunion(tree: Tree, cb: (key: TreeId) => any) {\n    tree.fnsMap.forEach((set, key) => {\n      const fns = this._getFns(key)\n      set.forEach(fn => fns.delete(fn) && cb(fn._ownerAtomId))\n    })\n  }\n\n  forEach(key: Leaf, ctx: Ctx) {\n    const setCounted = this.fnsMap.get(key)\n    if (setCounted) setCounted.forEach(fn => fn(ctx))\n  }\n}\n","import { Tree, TreeId } from './kernel'\nimport { Atom } from './declareAtom'\nimport { PayloadActionCreator } from './declareAction'\n\nexport { TreeId }\nexport type GenId = (name: string | [string] | symbol) => TreeId\nexport const TREE = Symbol('@@Reatom/TREE')\n\nexport type Unit = { [TREE]: Tree }\n\nexport type NonUndefined<T> = Exclude<T, undefined>\n\n/**\n * Helper for retrieving the data type used in an atom or action\n * @example\n * type MyAtomType = InferType<typeof myAtom>\n * type MyActionType = InferType<typeof myAction>\n */\nexport type InferType<T> = T extends\n  | Atom<infer R>\n  | PayloadActionCreator<infer R>\n  ? R\n  : never\n\nexport function noop() {}\n\n// eslint-disable-next-line prefer-destructuring\nexport const assign = Object.assign\n\nexport const equals = Object.is\n\nexport function getTree(thing: Unit): Tree {\n  return thing && thing[TREE]\n}\n\nexport function getName(treeId: TreeId): string {\n  return typeof treeId === 'symbol'\n    ? treeId.description || treeId.toString().replace(/Symbol\\((.*)\\)/, '$1')\n    : treeId\n}\n\nexport function getIsAtom(thing: any): thing is Atom<any> {\n  const vertex = getTree(thing)\n  return Boolean(vertex && !vertex.isLeaf)\n}\n\nexport function getIsAction(thing: any): thing is Atom<any> {\n  const vertex = getTree(thing)\n  return Boolean(vertex && vertex.isLeaf)\n}\n\nlet id = 0\nexport function nameToIdDefault(name: string | [string] | symbol): TreeId {\n  return typeof name === 'symbol'\n    ? // TODO: https://github.com/microsoft/TypeScript/issues/1863\n      ((name as unknown) as string)\n    : Array.isArray(name)\n    ? safetyStr(name[0], 'name')\n    : `${safetyStr(name, 'name')} [${++id}]`\n}\nlet _nameToId: GenId\nexport function nameToId(name: string | [string] | symbol): TreeId {\n  return _nameToId ? _nameToId(name) : nameToIdDefault(name)\n}\n\nexport function setNameToId(gen: GenId) {\n  _nameToId = safetyFunc(gen, 'gen')\n}\n\nexport function throwError(error: string) {\n  // TODO: add link to docs with full description\n  throw new Error(`[reatom] ${error}`)\n}\nexport function safetyStr(str: string, name: string): string {\n  if (typeof str !== 'string' || str.length === 0) throwError(`Invalid ${name}`)\n  return str\n}\nexport function safetyFunc<T extends Function>(\n  func: T | undefined,\n  name: string,\n): T {\n  if (typeof func !== 'function') throwError(`Invalid ${name}`)\n  return func as T\n}\n\nexport function getOwnKeys<T extends object>(obj: T): Array<keyof T> {\n  const keys = Object.keys(obj) as Array<keyof T>\n  keys.push(...(Object.getOwnPropertySymbols(obj) as Array<keyof T>))\n\n  return keys\n}\n","import { Leaf, Tree, BaseAction } from './kernel'\nimport { TREE, nameToId, Unit } from './shared'\nimport { Store } from './createStore'\n\nexport type ActionType = Leaf\nexport type Reaction<T> = (payload: T, store: Store) => any\n\nexport type Action<Payload, Type extends ActionType = string> = BaseAction<\n  Payload\n> & {\n  type: Type\n  reactions?: Reaction<Payload>[]\n}\n\nexport type BaseActionCreator<Type extends string = string> = {\n  getType: () => Type\n} & Unit\n\nexport type ActionCreator<Type extends string = string> = BaseActionCreator<\n  Type\n> &\n  (() => Action<undefined, Type>)\n\nexport type PayloadActionCreator<\n  Payload,\n  Type extends string = string\n> = BaseActionCreator<Type> & ((payload: Payload) => Action<Payload, Type>)\n\nexport function declareAction(\n  name?: string | Reaction<undefined>,\n  ...reactions: Reaction<undefined>[]\n): ActionCreator<string>\n\nexport function declareAction<Type extends ActionType>(\n  name: [Type],\n  ...reactions: Reaction<undefined>[]\n): ActionCreator<Type>\n\nexport function declareAction<Payload>(\n  name?: string | Reaction<Payload>,\n  ...reactions: Reaction<Payload>[]\n): PayloadActionCreator<Payload, string>\n\nexport function declareAction<Payload, Type extends ActionType>(\n  name: [Type],\n  ...reactions: Reaction<Payload>[]\n): PayloadActionCreator<Payload, Type>\n\nexport function declareAction<\n  Payload = undefined,\n  Type extends ActionType = string\n>(\n  name: string | [Type] | Reaction<Payload> = 'action',\n  ...reactions: Reaction<Payload>[]\n): ActionCreator<Type> | PayloadActionCreator<Payload, Type> {\n  if (typeof name === 'function') {\n    reactions.unshift(name)\n    name = 'action'\n  }\n  const id = nameToId(name)\n\n  const ACTree = new Tree(id, true)\n\n  const actionCreator = function actionCreator(payload?: Payload) {\n    return {\n      type: id,\n      payload,\n      reactions,\n    }\n  } as ActionCreator<Type> | PayloadActionCreator<Payload, Type>\n\n  actionCreator[TREE] = ACTree\n  actionCreator.getType = () => id as Type\n\n  return actionCreator\n}\n","import { Tree, State, TreeId, Ctx, createCtx, Leaf } from './kernel'\nimport {\n  TREE,\n  nameToId,\n  NonUndefined,\n  Unit,\n  throwError,\n  getTree,\n  safetyFunc,\n  getIsAction,\n  assign,\n  getName,\n  equals,\n  getOwnKeys,\n} from './shared'\nimport { Action, declareAction, PayloadActionCreator } from './declareAction'\n\nconst DEPS = Symbol('@@Reatom/DEPS')\nconst DEPS_SHAPE = Symbol('@@Reatom/DEPS_SHAPE')\n\n// action for set initialState of each atom to global state\nexport const init = declareAction(['@@Reatom/init'])\nexport const initAction = init()\n\ntype AtomName = TreeId | [string]\ntype AtomsMap = { [key: string]: Atom<any> }\ntype Reducer<TState, TValue> = (state: TState, value: TValue) => TState\n\n/**\n * This interface needed for correct type inference with TypeScript 3.5\n * @see https://github.com/artalar/reatom/issues/301\n */\ninterface DependencyMatcherOn<TState> {\n  <T>(dependency: Atom<T>, reducer: Reducer<TState, T>): void\n  <T>(dependency: PayloadActionCreator<T>, reducer: Reducer<TState, T>): void\n  <T>(\n    dependency: Atom<T> | PayloadActionCreator<T>,\n    reducer: Reducer<TState, T>,\n  ): void\n}\ntype DependencyMatcher<TState> = (on: DependencyMatcherOn<TState>) => any\n\nexport interface Atom<T> extends Unit {\n  (state?: State, action?: Action<any>): Record<string, T | any>\n  [DEPS]: Set<TreeId>\n  [DEPS_SHAPE]?: AtomsMap | TupleOfAtoms\n}\n\nexport function declareAtom<TState>(\n  initialState: TState,\n  dependencyMatcher: DependencyMatcher<TState>,\n): Atom<TState>\nexport function declareAtom<TState>(\n  name: AtomName,\n  initialState: TState,\n  dependencyMatcher: DependencyMatcher<TState>,\n): Atom<TState>\nexport function declareAtom<TState>(\n  name: AtomName | TState,\n  initialState: TState | DependencyMatcher<TState>,\n  dependencyMatcher?: DependencyMatcher<TState>,\n): Atom<TState> {\n  if (!dependencyMatcher) {\n    dependencyMatcher = initialState as DependencyMatcher<TState>\n    initialState = name as TState\n    name = 'atom'\n  }\n\n  const _id = nameToId(name as AtomName)\n  const _name = getName(_id)\n\n  if (initialState === undefined)\n    throwError(`Atom \"${_name}\". Initial state can't be undefined`)\n\n  const _tree = new Tree(_id)\n  const _deps = new Set<TreeId>()\n  // start from `0` for missing `actionDefault`\n  let dependencePosition = 0\n  const initialPhase = true\n\n  function on<T>(\n    dep: Unit | PayloadActionCreator<T>,\n    reducer: Reducer<TState, T>,\n  ) {\n    if (!initialPhase)\n      throwError(\"Can't define dependencies after atom initialization\")\n\n    safetyFunc(reducer, 'reducer')\n\n    const position = dependencePosition++\n    const depTree = getTree(dep as Unit)\n    if (!depTree) throwError('Invalid dependency')\n    const depId = depTree.id\n\n    const isDepActionCreator = getIsAction(dep)\n\n    _tree.union(depTree)\n\n    const update = function update({\n      state,\n      stateNew,\n      payload,\n      changedIds,\n      type,\n    }: Ctx) {\n      const atomStateSnapshot = state[_id as string]\n      // first `walk` of lazy (dynamically added by subscription) atom\n      const isAtomLazy = atomStateSnapshot === undefined\n\n      if (!isAtomLazy && type === initAction.type && !payload) return\n\n      const atomStatePreviousReducer = stateNew[_id as string]\n      // it is mean atom has more than one dependencies\n      // that depended from dispatched action\n      // and one of the atom reducers already processed\n      const hasAtomNewState = atomStatePreviousReducer !== undefined\n      const atomState = (hasAtomNewState\n        ? atomStatePreviousReducer\n        : atomStateSnapshot) as TState\n\n      const depStateSnapshot = state[depId as string]\n      const depStateNew = stateNew[depId as string]\n      const isDepChanged = depStateNew !== undefined\n      const depState = isDepChanged ? depStateNew : depStateSnapshot\n      const depValue = isDepActionCreator ? payload : depState\n\n      if (isDepActionCreator || isDepChanged || isAtomLazy) {\n        const atomStateNew = reducer(atomState, depValue)\n\n        if (atomStateNew === undefined)\n          throwError(\n            `Invalid state. Reducer number ${position} in \"${_name}\" atom returns undefined`,\n          )\n\n        if (hasAtomNewState && equals(atomStateSnapshot, atomStateNew)) {\n          changedIds.splice(changedIds.indexOf(_id), 1)\n          delete stateNew[_id as string]\n\n          return\n        }\n\n        if (!equals(atomState, atomStateNew)) {\n          if (!hasAtomNewState) changedIds.push(_id)\n\n          stateNew[_id as string] = atomStateNew\n        }\n      }\n    }\n    update._ownerAtomId = _id\n\n    if (isDepActionCreator) return _tree.addFn(update, depId as Leaf)\n    if (_deps.has(depId)) throwError('One of dependencies has the equal id')\n    _deps.add(depId)\n    depTree.fnsMap.forEach((_, key) => _tree.addFn(update, key))\n  }\n\n  on(init, (_, { [_id]: state = initialState }: any = {}) => state)\n  dependencyMatcher(on)\n\n  const atom = function atom(\n    state: State = {},\n    action: Action<any> = initAction,\n  ) {\n    const ctx = createCtx(state, action)\n    _tree.forEach(action.type, ctx)\n\n    const { changedIds, stateNew } = ctx\n\n    return changedIds.length > 0 ? assign({}, state, stateNew) : state\n  } as Atom<TState>\n\n  atom[TREE] = _tree\n  atom[DEPS] = _deps\n\n  return atom\n}\n\nexport function getState<T>(state: State, atom: Atom<T>): T | undefined {\n  return state[atom[TREE].id as string] as T | undefined\n}\n\nexport function map<T, TSource = unknown>(\n  source: Atom<TSource>,\n  mapper: (dependedAtomState: TSource) => NonUndefined<T>,\n): Atom<T>\nexport function map<T, TSource = unknown>(\n  name: AtomName,\n  source: Atom<TSource>,\n  mapper: (dependedAtomState: TSource) => NonUndefined<T>,\n): Atom<T>\nexport function map<T, TSource = unknown>(\n  name: AtomName | Atom<TSource>,\n  source: ((dependedAtomState: TSource) => T) | Atom<TSource>,\n  mapper?: (dependedAtomState: TSource) => NonUndefined<T>,\n) {\n  if (!mapper) {\n    mapper = source as (dependedAtomState: TSource) => NonUndefined<T>\n    source = name as Atom<TSource>\n    name = Symbol(`${getName(getTree(source).id)} [map]`)\n  }\n  safetyFunc(mapper, 'mapper')\n\n  return declareAtom<T>(\n    name as AtomName,\n    // FIXME: initialState for `map` :thinking:\n    null as any,\n    handle =>\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      handle(source as Atom<TSource>, (state, payload) => mapper!(payload)),\n  )\n}\n\ntype TupleOfAtoms = [Atom<unknown>] | Atom<unknown>[]\n\nexport function combine<T extends AtomsMap | TupleOfAtoms>(\n  shape: T,\n): Atom<{ [key in keyof T]: T[key] extends Atom<infer S> ? S : never }>\nexport function combine<T extends AtomsMap | TupleOfAtoms>(\n  name: AtomName,\n  shape: T,\n): Atom<{ [key in keyof T]: T[key] extends Atom<infer S> ? S : never }>\nexport function combine<T extends AtomsMap | TupleOfAtoms>(\n  name: AtomName | T,\n  shape?: T,\n) {\n  if (arguments.length === 1) shape = name as T\n\n  const isArray = Array.isArray(shape)\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const keys = getOwnKeys(shape!) as TreeId[]\n\n  if (arguments.length === 1)\n    name = isArray\n      ? Symbol(\n          `[${keys\n            .map(k => getName(getTree((shape as TupleOfAtoms)[k as any]).id))\n            .join()}]`,\n        )\n      : Symbol(`{${keys.map(getName).join()}}`)\n\n  const atom = declareAtom(name as AtomName, isArray ? [] : {}, reduce =>\n    keys.forEach(key =>\n      reduce((shape as any)[key], (state, payload) => {\n        const newState: any = isArray\n          ? (state as any[]).slice(0)\n          : assign({}, state)\n        newState[key] = payload\n        return newState\n      }),\n    ),\n  )\n  atom[DEPS_SHAPE] = shape\n  return atom\n}\n\nexport function getDepsShape(\n  thing: Atom<any>,\n): AtomsMap | TupleOfAtoms | undefined {\n  return thing[DEPS_SHAPE]\n}\n","import { Tree, State, TreeId, createCtx, BaseAction } from './kernel'\nimport {\n  throwError,\n  getTree,\n  safetyFunc,\n  assign,\n  getIsAtom,\n  getIsAction,\n  getOwnKeys,\n} from './shared'\nimport { Action, PayloadActionCreator } from './declareAction'\nimport { Atom, initAction, getState } from './declareAtom'\n\ntype ActionsSubscriber = (action: Action<unknown>, stateDiff: State) => any\ntype SubscribeFunction = {\n  <T>(\n    target: Atom<T> | PayloadActionCreator<T>,\n    listener: (state: T) => any,\n  ): () => void\n  (listener: ActionsSubscriber): () => void\n}\ntype GetStateFunction = {\n  <T>(target: Atom<T>): T\n  (): State\n}\n\nexport type Store = {\n  dispatch: <T>(action: Action<T>) => void\n  subscribe: SubscribeFunction\n  getState: GetStateFunction\n  bind: <A extends (...a: any[]) => BaseAction>(\n    a: A,\n  ) => (...a: A extends (...a: infer Args) => any ? Args : never) => void\n}\n\nexport function createStore(initState?: State): Store\nexport function createStore(atom: Atom<any>, initState?: State): Store\n// TODO: try to use ES6 Map's instead of plain object\n// for prevent using `delete` operator\n// (need perf tests)\nexport function createStore(\n  atom?: Atom<any> | State,\n  initState?: State,\n): Store {\n  let listeners: Map<TreeId, Function[]> = new Map<TreeId, Function[]>()\n  let nextListeners: Map<TreeId, Function[]> = listeners\n  let dispatchListeners: Function[] = []\n  let nextDispatchListeners: Function[] = dispatchListeners\n  let initialAtoms = new Set<TreeId>()\n  let state: State = {}\n  const storeTree = new Tree('store')\n  if (atom !== undefined) {\n    if (typeof atom === 'object' && initState === undefined) assign(state, atom)\n    else {\n      if (!getIsAtom(atom)) throwError('Invalid atom')\n      if (typeof initState === 'object' && initState !== null)\n        assign(state, initState)\n      else if (initState !== undefined) throwError('Invalid initial state')\n\n      storeTree.union(getTree(atom as Atom<any>))\n      const ctx = createCtx(state, initAction)\n      storeTree.forEach(initAction.type, ctx)\n      assign(state, ctx.stateNew)\n      initialAtoms = new Set(getOwnKeys(ctx.stateNew))\n    }\n  }\n\n  function ensureCanMutateNextDispatchListeners() {\n    if (nextDispatchListeners === dispatchListeners) {\n      nextDispatchListeners = dispatchListeners.slice()\n    }\n  }\n\n  function ensureCanMutateNextListeners(treeId: TreeId) {\n    if (nextListeners === listeners) {\n      nextListeners = new Map()\n      listeners.forEach((value, key) =>\n        nextListeners.set(key, treeId === key ? value.slice() : value),\n      )\n    }\n  }\n\n  function _getState(): State\n  function _getState<T>(target?: Atom<T>): State | T {\n    // TODO: try to cache `assign`\n    if (target === undefined) return assign({}, state) as State\n\n    if (!getIsAtom(target)) throwError('Invalid target')\n\n    const targetState = getState<T>(state, target)\n    if (targetState !== undefined) return targetState\n\n    const ctx = createCtx(state, initAction)\n    getTree(target).forEach(initAction.type, ctx)\n\n    return getState(ctx.stateNew, target)\n  }\n\n  function subscribe(subscriber: ActionsSubscriber): () => void\n  function subscribe<T>(\n    target: Atom<T> | PayloadActionCreator<T>,\n    subscriber: (state: T) => any,\n  ): () => void\n  function subscribe<T>(\n    target: Atom<T> | PayloadActionCreator<T> | ActionsSubscriber,\n    subscriber?: (state: T) => any,\n  ): () => void {\n    const listener = safetyFunc(subscriber || target, 'listener')\n    let isSubscribed = true\n\n    if (subscriber === undefined) {\n      if (getIsAtom(listener) || getIsAction(listener))\n        throwError('Invalid listener')\n\n      ensureCanMutateNextDispatchListeners()\n      nextDispatchListeners.push(listener)\n      return () => {\n        if (!isSubscribed) return\n        isSubscribed = false\n        ensureCanMutateNextDispatchListeners()\n        nextDispatchListeners.splice(nextDispatchListeners.indexOf(listener), 1)\n      }\n    }\n\n    const isAction = getIsAction(target)\n    if (!getIsAtom(target) && !isAction)\n      throwError('Invalid subscription target')\n    const targetTree = getTree(target as Atom<T> | PayloadActionCreator<T>)\n    const targetId = targetTree.id\n    const isLazy = !isAction && !initialAtoms.has(targetId)\n\n    ensureCanMutateNextListeners(targetId)\n    if (!nextListeners.has(targetId)) {\n      nextListeners.set(targetId, [])\n      if (isLazy) {\n        storeTree.union(targetTree)\n        const ctx = createCtx(state, initAction)\n        targetTree.forEach(initAction.type, ctx)\n        assign(state, ctx.stateNew)\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    nextListeners.get(targetId)!.push(listener)\n\n    return () => {\n      if (!isSubscribed) return\n      isSubscribed = false\n\n      ensureCanMutateNextListeners(targetId)\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const _listeners = nextListeners.get(targetId)!\n      _listeners.splice(_listeners.indexOf(listener), 1)\n\n      if (isLazy && _listeners.length === 0) {\n        nextListeners.delete(targetId)\n        storeTree.disunion(targetTree, id => {\n          delete state[id as string]\n        })\n      }\n    }\n  }\n\n  function dispatch(action: Action<any>) {\n    const { type, payload, reactions } = action\n    if (\n      typeof action !== 'object' ||\n      action === null ||\n      typeof type !== 'string'\n    )\n      throwError('Invalid action')\n\n    const ctx = createCtx(state, action)\n    storeTree.forEach(type, ctx)\n\n    const { changedIds, stateNew } = ctx\n\n    listeners = nextListeners\n\n    if (type === initAction.type) state = payload || {}\n    if (changedIds.length > 0) {\n      assign(state, stateNew)\n      for (let i = 0; i < changedIds.length; i++) {\n        const id = changedIds[i]\n        callFromList(listeners.get(id) || [], stateNew[id as string])\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    callFromList(reactions || [], payload, store)\n    callFromList(listeners.get(type) || [], payload)\n    callFromList((dispatchListeners = nextDispatchListeners), action, stateNew)\n  }\n\n  const bind: Store['bind'] = actionCreator => (...a) =>\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    store.dispatch(actionCreator(...a))\n\n  const store = {\n    getState: _getState,\n    subscribe,\n    dispatch,\n    bind,\n  }\n\n  return store\n}\n\nfunction callFromList(list: Function[], ...arg: any[]) {\n  let i = -1\n  while (++i < list.length) list[i](...arg)\n}\n"],"names":["createCtx","state","stateNew","type","payload","changedIds","SetCounted","this","Map","add","el","_counter","set","get","count","forEach","cb","_","fn","Tree","id","isLeaf","fnsMap","_getFns","key","addFn","union","tree","fns","_this","disunion","_this2","_ownerAtomId","ctx","setCounted","TREE","Symbol","noop","assign","Object","equals","is","getTree","thing","getName","treeId","description","toString","replace","getIsAtom","vertex","Boolean","getIsAction","_nameToId","nameToIdDefault","name","Array","isArray","safetyStr","nameToId","setNameToId","gen","safetyFunc","throwError","error","Error","str","length","func","getOwnKeys","obj","keys","push","getOwnPropertySymbols","declareAction","reactions","unshift","ACTree","actionCreator","getType","DEPS","DEPS_SHAPE","init","initAction","declareAtom","initialState","dependencyMatcher","_id","_name","undefined","_tree","_deps","Set","dependencePosition","on","dep","reducer","position","depTree","depId","isDepActionCreator","update","atomStateSnapshot","isAtomLazy","atomStatePreviousReducer","hasAtomNewState","atomState","depStateNew","isDepChanged","atomStateNew","splice","indexOf","has","atom","action","getState","map","source","mapper","handle","combine","shape","arguments","k","join","reduce","newState","slice","getDepsShape","createStore","initState","listeners","nextListeners","dispatchListeners","nextDispatchListeners","initialAtoms","storeTree","ensureCanMutateNextDispatchListeners","ensureCanMutateNextListeners","value","store","target","targetState","subscribe","subscriber","listener","isSubscribed","isAction","targetTree","targetId","isLazy","_listeners","dispatch","i","callFromList","bind","list"],"mappings":"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"}